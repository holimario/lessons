# 网络层路由实验

无04  2019012137  张鸿琳

## 实验目的

- 理解和掌握链路状态法和距离向量法的实现原理和区别；
- 理解和掌握链路状态法和距离向量法处理链路故障和新增链路的方式；
- 分析和对比链路状态法和距离向量法的计算复杂度和实际收敛速度；
- 初步掌握编程实现路由选择算法的能力。

## 实验内容

- 理解实验原理，熟悉网络仿真器和图形化交互式界面；
- 阅读实验提供代码，掌握网络仿真器运行原理，理解网络仿真器中数据包、链路、客户端和路由器的具体实现；
- 阅读并补全链路状态法的关键代码，确定算法原理和代码实现的对应关系，掌握 Dijkstra 算法在其中的应用；
- 在网络仿真器中运行链路状态法，对比链路状态正常、链路故障和链路新增三种情况时路由路径和路由表变化；
- 在网络仿真器中运行距离向量法，对比链路状态正常、链路故障和链路新增三种情况时路由路径和路由表变化；
- 记录并对比链路状态法和距离向量法收敛速度，并分析实验现象。

## 实验原理

​		路由是网络层至关重要的功能，需要确定从发送方到接收方所采用的一个“好”的路径，具体体现在成本最低、速度最快、开销最小等标准，为方便表述，下文统一用开销最小作为“好”的路径标准。具体而言，网络通过路由协议事先约定路由信息的发送过程的规定和标准，进行路由信息交换。常用的路由协议包括路由信息协议（RIP）、开放式最短路径优先协议（OSPF）和边界网关协议（BGP） 等。路由选择算法则在路由协议中起着至关重要的作用，采用的路由选择算法决定了寻找最终路径的结果。常用的路由选择算法包括链路状态法（Link State，LS， 对应 OSPF 协议）和距离向量法（Distance Vector，DV，对应 RIP 协议），本次实验将针对上述两种路由选择算法进行实现，并根据实验现象对比分析。

​		链路状态法的基本原理是节点之间传递链路状态和开销等信息，基于收到的链路状态信息，每个节点能够找到通往任意节点的最小开销路径。特别地，网络通过可靠洪泛（Reliable Flooding）保证所有节点都能得到来自其他节点的链路状态信息：一个节点沿着所有与其直接相连的链路把其链路状态信息发送出去，接收到这个信息的每个节点再沿着所有与它相连的链路转发出去，这个过程一直持续直到这个信息到达网络中所有节点。

​		距离向量法的基本原理是在每个路由器节点构建一个距离向量，其中包含与所有其他路由器节点的开销，并将其距离向量传递给邻居节点。网络在运行距离向量法时，节点之间互相交换其所拥有的距离向量，并更新自身路由表，当所有节点获取一致的路由信息时，则算法收敛。每个节点仅知道自己路由表的内容，即由自身发送数据包到其他节点的距离和下一跳节点。

## 实验过程与结果

### 5.2 链路状态法理解与实现

​		首先对初始化函数中的变量作注释，如下：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_19 22_42_31](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_19%2022_42_31.png)

​		再根据链路状态法原理以及前向搜索算法流程，将路径规划函数补全代码，并对其进行注释，如下：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_19 22_42_38](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_19%2022_42_38.png)

​		在补全代码后，运行正常网络，得到下图：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_18 22_36_33](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_18%2022_36_33.png)

​		可以看到最终结果是正确的，记录信息，完成下面表格：

- 客户端之间的最小开销路径：

| 源客户端-目的客户端 |          最小开销路径           |
| :-----------------: | :-----------------------------: |
|       A$\to$A       |          A$\to$u$\to$A          |
|       A$\to$B       | A$\to$u$\to$x$\to$y$\to$z$\to$B |
|       A$\to$C       | A$\to$u$\to$x$\to$y$\to$w$\to$C |
|       B$\to$A       | B$\to$z$\to$y$\to$x$\to$u$\to$A |
|       B$\to$B       |          B$\to$z$\to$B          |
|       B$\to$C       |    B$\to$z$\to$y$\to$w$\to$C    |
|       C$\to$A       | C$\to$w$\to$y$\to$x$\to$u$\to$A |
|       C$\to$B       |    C$\to$w$\to$y$\to$z$\to$B    |
|       C$\to$C       |          C$\to$w$\to$C          |

- 路由器 x 的转发表：

| 目的节点 | 下一跳转发节点 | 开销 |
| :------: | :------------: | :--: |
|    A     |       u        |  2   |
|    B     |       y        |  4   |
|    C     |       y        |  3   |
|    u     |       u        |  1   |
|    v     |       v        |  2   |
|    w     |       y        |  2   |
|    x     |       x        |  0   |
|    y     |       y        |  1   |
|    z     |       y        |  3   |

- 路由器 x 的LSP信息记录：

| 紧邻节点 | 开销 |
| :------: | :--: |
|    y     |  1   |
|    u     |  1   |
|    w     |  3   |
|    v     |  2   |



### 5.3 链路状态改变实验

​		给移除链路的函数加上注释，如下：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_19 22_42_43](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_19%2022_42_43.png)

​		运行链路故障（移除）网络，利用链路状态法进行路由选择，得到下图：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_18 22_47_59](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_18%2022_47_59.png)

​		可以看到最终结果是正确的，记录信息，完成下面表格：

- 客户端之间的最小开销路径：

| 源客户端-目的客户端 |          最小开销路径           |
| :-----------------: | :-----------------------------: |
|       A$\to$A       |          A$\to$u$\to$A          |
|       A$\to$B       | A$\to$u$\to$x$\to$y$\to$z$\to$B |
|       A$\to$C       |    A$\to$u$\to$x$\to$w$\to$C    |
|       B$\to$A       | B$\to$z$\to$y$\to$x$\to$u$\to$A |
|       B$\to$B       |          B$\to$z$\to$B          |
|       B$\to$C       |       B$\to$z$\to$w$\to$C       |
|       C$\to$A       |    C$\to$w$\to$x$\to$u$\to$A    |
|       C$\to$B       |       C$\to$w$\to$z$\to$B       |
|       C$\to$C       |          C$\to$w$\to$C          |

- 路由器 x 的转发表：

| 目的节点 | 下一跳转发节点 | 开销 |
| :------: | :------------: | :--: |
|    A     |       u        |  2   |
|    B     |       y        |  4   |
|    C     |       w        |  4   |
|    u     |       u        |  1   |
|    v     |       v        |  2   |
|    w     |       w        |  3   |
|    x     |       x        |  0   |
|    y     |       y        |  1   |
|    z     |       y        |  3   |

- 路由器 x 的LSP信息记录如下：

| 紧邻节点 | 开销 |
| :------: | :--: |
|    y     |  1   |
|    u     |  1   |
|    w     |  3   |
|    v     |  2   |

​		此后再运行链路新增网络，得到下图：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_18 22_57_00](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_18%2022_57_00.png)

​		可以看到最终结果是正确的，记录信息，完成下面表格：

- 客户端之间的最小开销路径：

| 源客户端-目的客户端 |          最小开销路径           |
| :-----------------: | :-----------------------------: |
|       A$\to$A       |          A$\to$u$\to$A          |
|       A$\to$B       |    A$\to$u$\to$x$\to$z$\to$B    |
|       A$\to$C       | A$\to$u$\to$x$\to$y$\to$w$\to$C |
|       B$\to$A       |    B$\to$z$\to$x$\to$u$\to$B    |
|       B$\to$B       |          B$\to$z$\to$B          |
|       B$\to$C       |    B$\to$z$\to$y$\to$w$\to$C    |
|       C$\to$A       | C$\to$w$\to$y$\to$x$\to$u$\to$A |
|       C$\to$B       |    C$\to$w$\to$y$\to$z$\to$B    |
|       C$\to$C       |          C$\to$w$\to$C          |

- 路由器 x 的转发表：

| 目的节点 | 下一跳转发节点 | 开销 |
| :------: | :------------: | :--: |
|    A     |       u        |  2   |
|    B     |       z        |  3   |
|    C     |       y        |  3   |
|    u     |       u        |  1   |
|    v     |       v        |  2   |
|    w     |       y        |  2   |
|    x     |       x        |  0   |
|    y     |       y        |  1   |
|    z     |       z        |  2   |

- 路由器 x 的LSP信息记录如下：

| 紧邻节点 | 开销 |
| :------: | :--: |
|    y     |  1   |
|    z     |  2   |
|    u     |  1   |
|    w     |  3   |
|    v     |  2   |

​		通过比较链路状态改变和正常状态时最小开销路径和路由器转发表、LSP 的信息，可以看到链路状态法处理链路状态改变的过程大致为：当发生某条链路的状态改变，则该链路对应的路由器将会向周围路由器发出更新的 LSP 信息数据包（洪泛开来），随后各个路由器会根据这收到的新的 LSP 信息重新进行路径规划（利用 Dijikstra 算法），进而得到新的转发表（最小开销），所有路由器的转发表都更新完毕后，当有数据包传入网络，该数据包会被路由器（根据其更新过后的转发表）不断转发，这些转发串联起来就是新的最小开销路径了。



### 5.4 距离向量法理解与实验

​		利用距离向量法对上面三种情况的链路网络进行路径规划（得到转发表），得到最终运行结果如下图（依次为正常、链路故障、链路新增）：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_21 16_33_18](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_21%2016_33_18.png)

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_21 16_34_41](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_21%2016_34_41.png)

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_21 16_35_51](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_21%2016_35_51.png)

​		**【选做】**在阅读 DVrouter.py 代码后，我给 DV 算法的更新函数做了注释，如下：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_19 22_42_52](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_19%2022_42_52.png)

​		根据上述代码，我理解的 DV 实现过程如下：

- 当某一 $x$ 路由器收到来自周围紧邻的路由器发来的 DV 信息数据包时，则根据其进行自身 DV 的更新，更新时采用式子 $D_x(y)_{new}=\min[c(x,v)+D_v(y),D_x(y)_{old}]$ ，其中$D_v(y)$为紧邻 $v$ 路由器距离 $y$ 路由器最小的开销值（是包含在 DV 数据包中的信息），而 $c(x,v)$ 为当前 $x$ 路由器到该紧邻的 $v$ 的直接链路开销（记录在当前 $x$ 路由器中）， $D_x(y)_{old}$ 为此前记录的该 $x$ 路由器到 $y$ 节点的最小开销（记录在当前 $x$ 路由器中），$D_x(y)_{new}$ 为更新后的该 $x$ 路由器到 $y$ 节点的最小开销（如果发生链路断开现象，则受到影响的 $D_x(y)_{new}$ 会无条件更新为某一对应于链路断开状态的极大值）；
- 每当某个路由器的 DV （距离向量）状态发生更新，则其将该更新转发给周围的紧邻路由器（路由器也会周期性地向紧邻路由器发送自身 DV 信息），该 DV 信息数据包中包含的是发送该数据包的路由器地址、其更新的到达节点的地址、更新后到达该节点的最小开销。

​		通过这一过程，在紧邻路由器之间不断的 DV 信息数据包交流中，最后各个路由器的转发表会收敛到某一结果，本质上实现了 $D_x(y)=\min\limits_v[c(x,v)+D_v(y)]$ 这一式子（ $v$ 为 $x$ 的各个紧邻节点）。



### 5.5 路由选择算法效率比较

​		在不同的网络拓扑结构上执行不同路由选择算法，记录从开始运行到第一次出现路由正确的收敛时间，得到下表：

| 收敛时间(s)    | 链路正常 | 链路故障 | 链路新增 |
| -------------- | -------- | -------- | -------- |
| **距离向量法** | 25.19    | 45.36    | 45.32    |
| **链路状态法** | 45.33    | 55.42    | 55.32    |



## 实验思考题

**(1) 请给出你对 LSP.py 中 LSP 更新函数的执行过程的理解。**

​		根据我的理解，我对 LSP 更新函数进行了注释，如下：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_19 22_38_30](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_19%2022_38_30.png)

​		从上面注释可以看出，LSP 更新函数的思路十分简洁，先根据序列号判断传入的数据是否是新的，当数据包是新的，则更新序列号，再根据传入数据包和当前存储数据包是否一致，若不一致则更新。



**(2) 在距离向量法实现中，下面代码基于 Bellman-Ford 方程进行距离向量更新时，其中的 self.linksCost[src] 能否换成 self.routersCost[src] ，请说明原因。**

![实验3-指导书.pdf 和另外 1 个页面 - 个人 - Microsoft Edge 2022_10_19 20_34_02](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/%E5%AE%9E%E9%AA%8C3-%E6%8C%87%E5%AF%BC%E4%B9%A6.pdf%20%E5%92%8C%E5%8F%A6%E5%A4%96%201%20%E4%B8%AA%E9%A1%B5%E9%9D%A2%20-%20%E4%B8%AA%E4%BA%BA%20-%20Microsoft%E2%80%8B%20Edge%202022_10_19%2020_34_02.png)

​		self.linksCost[src] 不能换成 self.routersCost[src] ，因为 self.linksCost[src] 中存储的是当前路由器直接到其紧邻路由器 src 的那条唯一链路的开销，而 self.routersCost[src] 中存储的是当前路由器到路由器 src 的一系列链路的总开销（更新后，就是到 src 的最小开销），而在 DV 算法的核心式子 $D_x(y)=\min\limits_v[c(x,v)+D_v(y)]$ 中，$c(x,v)$ 指的是当前路由器 $x$ 到其紧邻路由器 $v$ 的那条直接链路的开销，这和 self.linksCost 的含义是对应的。而且常常出现 self.linksCost[src] 和 self.routersCost[src] 是不等的情况（也就是通往 src 的最小开销途径不是直接由当前路由器指向 src 的那条链路），此时将 self.linksCost[src] 替换成 self.routersCost[src] 后就会导致更新的转发表（即通往 dst 需要途径的紧邻路由器）有误。

​		举个例子，比如下图：

![Exp3_VM_NEW- VMware Workstation 16 Player (仅用于非商业用途) 2022_10_18 22_57_00 (2)](C:/Users/%E6%83%A0%E6%99%AE/Videos/Captures/Exp3_VM_NEW-%20VMware%20Workstation%2016%20Player%20(%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94)%202022_10_18%2022_57_00%20(2).png)

​		从路由器 x 的视角来看，（用 w 指代路由器 w 的地址）self.linksCost[w] 的值为 3 ，而 self.routersCost[w] 的值为 2 ，那么如果用 self.routersCost[src] 替换了 self.linksCost[src] ，则在更新路径时，上述算法就有可能认为从 x 到 C 的最小开销链路为 x$\to$w$\to$C（也就是当 x 收到目的地为 C 的数据包时，x 会把该数据包转发到 w ），但是实际上从 x 到 C 的最小开销路径为 x$\to$y$\to$w$\to$C（当 x 收到目的地为 C 的数据包时，x 应该把该数据包转发到 y ），这就是不适当的替换带来的错误。

