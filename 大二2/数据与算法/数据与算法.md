# 数据与算法概论

## 基本概念

- 数据：数据是信息的载体，是对现实世界的抽象
- 数学模型：数学模型是对于客观世界的现实现象，根据其内在规律，经过简化得到的数学结构
- 算法：算法是对特定问题求解步骤的描述

## 算法复杂度

算法的五个重要特性：

- 有穷性：一个算法必须总是在执行有穷步之后结 束，且每一步都可在有穷时间内完成
- 确定性：算法的描述无歧义，算法的实际执行结 果是确定的且精确地符合要求或期望
- 可行性：算法中描述的操作都可以通过已经实现 的基本操作运算的有限次执行来实现
- 输入：一个算法有零个或多个输入，这些输入取 自某个特定的对象集
- 输出：一个算法有一个或多个输出，输出量是算 法计算的结果

算法的评价：

- 正确性
- 可读性
- 健壮性
- 高效率

系统的整体效率受到算法效率和硬件计算速度的影响

算法效率的衡量方法：

- 数据结构和算法策略的选择
- 问题的规模
- 编写程序的语言
- 编译程序产生的机器代码的质量
- 计算机速度
- 当前运行情况

一个特定算法的运行工作量的大小，是问题规模的函数

**算法的时间复杂度**：算法的渐近时间复杂度为$T(n)=O[f(n)]$，关注的是趋势，也就是问题规模足够大之后，算法时间复杂度遵循的规律。

**Big-O记号的形式化定义：**

- 标记的是算法效率的上限：若$f(n)$是正整数$n$的一个函数，则$x_n=O[f(n)]$表示存在正的常数$M$和$n_0$，使得当$n>n_0$时，都满足$|x_n|\le M|f(n)|$
- 如果$c$是一个正常数，$O[cf(x)]=O[f(n)]$
- 如果$g(n)$的阶数小于等于$f(n)$的阶数，有$O[f(n)+g(n)]=O[f(n)]$

**算法效率的估算方法：**

- 算法的执行时间=$\sum操作的执行次数\times 操作的执行时间$
- 算法操作包括控制结构和原操作
- 选取算法中的基本操作
- 算法的执行时间与基本操作执行次数之和成正比

### 算法时间复杂度分析

描述指标：

- 最好情况：对于任何一个输入的运行时间下限
- 最坏情况：对于任何一个输入的运行时间上限
- 平均情况：对大量输入的平均运行时间

最重要的是**平均情况**下的性能

### 空间复杂度

算法空间：

- 指令空间：用来存储程序指令所需空间
- 数据空间：存储运行过程中常量和变量所需的空间
- 环境空间：系统为程序运行，特别是函数调用提供的空间

算法的渐近空间复杂度：$S(n)=O[f(n)]$

输入数据所占空间只取决于问题本身，和算法无关，则只需要分析**除输入和程序之外的额外空间**

### 算法效率分析

算法效率分析包含了时间复杂度和空间复杂度。

引入𝐵𝑖𝑔𝑂表示的渐进时间复杂度和空间复杂度实际上是建立了 算法效率分析的数学模型。

在验证算法效率时，需要迅速找到会被多次反复执行的基本操作。

感兴趣的复杂度形式其实非常有限：$1,\log(n),n,n\log(n),n^2,n^2\log(n),n^3,2^n,n!$



# 基础数据结构

算法+数据结构=程序

- 程序：为计算机处理问题编制的一组指令集
- 数据结构：问题的数据模型
- 算法：处理问题的策略



程序设计主要进行的就是数据结构和算法的设计。

数据结构描述了存储和处理数据的方法，以便捷的对读取和修改数据

基础数据结构：链表、字符串、树、……



- 数据元素：数据的基本单位
- 数据项：数据结构中讨论的最小单位



数据结构是带结构的数据元素的集合：

- 逻辑结构
- 存储结构



## 二元关系

二元关系是描述数据之间关系的数学工具。

利用集合论中的符号体系，将各种数据集中数据元素之间 的关系用集合的语言精确描述出来。

计算机中的数据集合和数据元素之间的关系是动态的。

数据结构：

- 数据之间的关系
- 数据的存储结构
- 数据集上的操作



### 集合的笛卡尔积

集合$M$和$N$的笛卡尔积，记作$M\times N$。

不满足交换律。



### 二元关系的性质

设$R$是集合$M$上的一个二元关系：

- 自反性：对于每个$a\in M$，有$(a,a)\in R$
- 反自反性：对于每个$a\in M$，有$(a,a)\notin R$
- 对称性：当$(a,b)\in R$时，必有$(b,a)\in R$
- 反对称性：当$(a,b)\in R$且$(b,a)\in R$时，则$a=b$或者如果$(a,b)\in R$则$(b,a)\notin R$
- 传递性：当$(a,b)\in R$且$(b,c)\in R$时，必有$(a,c)\in R$



#### 等价关系

满足自反性、对称性、传递性的关系。

#### 偏序关系

满足自反性、反对称性、传递性的关系。

例子：。。。

#### 拟序关系

满足反自反性、传递性的关系。

例子：。。。

#### 全序关系

对于一个偏序关系，如果集合$M$中的任意两个元素$a$和$b$都是可比的，也就是说或者有$aRb$成立，或者有$bRa$成立，则称$R$是集合$M$上的全序关系。

例子：。。。



## 数据上的逻辑结构

从二元关系出发可以定义数据的逻辑结构，在宏观尺度上 反映数据元素之间在逻辑上的联系。

定义二元组$B=(D,R)$，其中$D$为数据元素的有限集合，$R$为$D$上的二元关系。



## 数据的存储结构

数据与算法都不依赖计算机存在，计算机的出现为数据的处理和算法的 实现提供了目前为止最好的平台和工具。

数据的存储结构是数据在计算机中的组织方式：

- 顺序存储：数据元素在存储器中的相对位置表示元素间的逻辑关系（数据元素的存储相对位置和元素间的逻辑关系是一致的）
- 链式存储：通过元素存储地址的附加指针来表示元素之间的逻辑关系（数据元素的存储相对位置和元素间的逻辑关系没有必然联系，数据元素之间的逻辑关系靠附加指针来维护）



## 数据类型

计算机语言中需要定义数据类型。

定义的背后是对关键属性和操作的约定。

**数据类型是一个元素的集合和定义在此集合上的一组操作的总称**：

- 一种封装好的数据结构，实现了信息的封装和隐藏
- 刻画了操作对象的外在特性
- 不必知道计算机的内部细节和如何实现操作
- 高级语言中的数据类型包含了原子类型和结构类型（比如定义复数）



## 抽象数据类型（ADT）

一个数学模型以及定义在此数学模型上的一组操作：

- 数据抽象：描述实体的本质，功能及外部的用户接口
- 数据封装：将实体的外部特性和内部实现细节分离，隐藏内部实现 细节，使用和现实分离



抽象数据类型与一般数据类型本质上是一致的：

- 允许用户自行定义
- 可以实现更高层次的抽象，具有更广泛的代表性

优点：

- 程序结构清晰，易于扩展，易于维护而不失其效率
- 提高了程序中数据安全性
- 大大增加了软件的复用程度



### 抽象数据类型的描述

。。。



## 线性表

最简单的数据结构

存在直接前驱和直接后继（除了第零个和最后一个）

有序是位序，数值上不一定有序



将线性表记为$(a_0,a_1,...,a_{i-1},a_i,a_{i+1},...,a_{n-1})$

线性表中元素的个数为线性表的长度



同一线性表中的元素必定具有相同特性

### 线性表的抽象数据类型

基本操作的分类：

- 构造型操作
- 销毁型操作
- 引用型操作
- 加工型操作
- 遍历



对于其他的数据类型，这些操作类似，但实现方式会有很 大差异。

计算机中的数据集合是动态的。



线性表的顺序存储方式就是顺序表：用一组地址连续的存储单元一次存 储线性表的数据元素。

顺序表中的元素存储：

- 基地址：第一个元素$a_0$的存储位置
- 假设每个单元占用$l$个存储单元
- 。。。





正确性：边缘情况

稳健性：边界判断、存在性判断、溢出判断



顺序表特性：

- 数据连续存储，与计算机内存对应
- 可以随机存取元素
- 插入删除操作时，需要进行大量的元素移动

### 链表——线性表的链式存储

链表特性：

- 逻辑上相邻的数据元素在存储地址上不需要相邻
- 依靠附加指针将逻辑上相邻的元素连接起来
- 每个数据元素包含数据和指针



#### 单向链表

最简单最一般的链表结构：

- 链表结点(Node)由两个域组成
- 数据域：存储数据元素
- 指针域：指向直接后继结点



链表中的操作与顺序表是一致的



单向链表的主要操作：

- 取元素位置：链表之中不存在“位序”的概念，无法直接计算得到元素的存储位置，通过多次指针的定向得到
- 插入元素
- 删除元素



判断是否为头结点增加了操作逻辑和代码实现的复杂度，所以引入了带表头结点的单向链表：

- 头指针被头结点代替，头结点永远存在，空表时链表中仍有一个结点
- 头结点中元素非集合中元素
- 统一处理链表各个位置的插入和删除



单向链表的缺点（以及特点）：

- 指针总是从前驱结点指向后继结点，访问后继结点容易，前驱结点难
- 获取表尾指针需要遍历整个链表，获得表长信息也是
- 插入或者删除元素时，需要在链表中依序寻找操作位置
- 元素的“位序”概念淡化，结点的“位置”概念强化



单向链表的改进：

- 增加“表长”、“表尾指针”和“当前位置的指针”三个数据域
- 将基本操作中的“位序 𝑖”改变为“指针 𝑝 ”



#### 双向循环链表

指针域包括前向指针和后向指针

优点：

- 寻找结点的直接前驱和直接后继
- 得到链表的尾结点

缺点：

- 插入删除操作需要同时修改两个方向的指针



## 栈与队列

**汉诺塔问题**

### 栈

栈是一种线性结构。

栈只允许在一端进行插入和删除。

**栈顶**是允许插入和删除的一端。

**栈底**是不操作的一端。

栈中数据元素的个数就是栈的长度。



先进后出（FILO），后进先出（LIFO）

#### 顺序栈

顺序栈的静态分配和动态分配。

#### 链式栈

基于链式存储

链式栈一般不会产生溢出，空间利用率高。



#### 栈的应用

栈可能是使用频率最高的数据结构。

显式应用：

- 括号匹配、进制转换、表达式求值、迷宫求解
- Graham扫描法：计算点集的凸包



隐式应用：

- 浏览器中的“前进”和“后退”
- 函数调用、递归
- 系统栈、内存管理



##### 括号匹配

逢左括弧进栈，逢右括弧，将对应的左括弧出栈，若无对应的左括弧，则为语法错误。

字符串结束，检查栈是否为空，得到括号配对检查结果。



##### 进制转换

逐次取余，依次入栈。

依次出栈，得到结果。



##### 表达式求值

- 中缀表达式
- 后缀表达式（逆波兰式）：表达式中不需要括号来确定优先级，对计算机最方便的求值形式
- 前缀表达式



操作数之间的相对次序不变；运算符的相对次序不同。



对于后缀表达式，遇到操作数进栈，遇到操作符，两个操作数出栈进行计算，结果进栈，栈顶元素就是后缀表达式求值的结果

对后缀表达式求值的进一步改进。



##### 计算点集的凸包

左旋

### 递归

**定义递归**：若一个对象部分地包含它自己，或用它自己给自己 定义，称这个对象是递归的；若一个过程直接地或间接地 调用自己，则称这个过程是递归的。

绝大多数现代的计算机语言支持递归，一些早期的语言由于机器指令集的限制不支持递归。



链表结点定义是递归的。



递归求解的两个条件：

- 找到了规模较大的问题和规模较小的同样问题之间的联系
- 具有中止条件



一个含直接或间接调用本函数语句的函数被称之为递归函 数，它必须满足以下两个条件：

- 在每一次调用自己时，必须是（在某种意义上）更接近于最终解
- 必须有一个终止处理或计算的准则



#### 递归例子

##### 阶乘求值

。。。

##### 求最大公因子

辗转相除法

。。。

##### 斐波那契数列

数列的通项：$F(n)=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n]$

##### 汉诺塔问题



#### 递归特点

递归优点：思路直接，代码简洁，易于理解

不足：可能导致较高的时间复杂度和空间复杂度



#### 递归的消除

通过消除递归获得更高的效率



**尾递归**：在递归程序中，递归语句只有一个，且处在函数的最后。

对于尾递归形式的递归算法，可以很方便的利用循环结构 来替代。

**单向递归**：递归算法中有多处递归调用，但各递归调用语 句的参数之间没有关系，并且这些递归调用语句都处在递 归算法的最后。

尾递归是单向递归的特例



一部分递归可直接用循环实现其非递归过程：

- 尾部的递归调用需要额外开销，却没有用它们进行什么有用的计算
- 消除尾部递归可以显著地改善递归函数的效率



一部分递归可用递推实现其非递归过程。

很多情形必须借助显式栈来实现非递归过程。

#### 递归总结

很多递归程序在运行时是利用系统的调用栈（call stack）实现的。



### 队列

队列是限定在表的一端进行插入，而在另一端进行删除的 线性结构。

在队列中，允许插入的一端称为队尾（rear），允许删除的 一端称为队头（front），插入操作称为入队（enqueue）， 删除操作称为出队（dequeue）。



FIFO：先进先出



#### 循环队列

存储队列的数组被当作首尾相 接的表处理：

- 当队尾指针指向maxSize -1时， 再入列可直接进到0
- 当队头指针指向maxSize -1，再 出列也直接进到0

（可用程序语言的取模（求余）来 实现）



当front=rear时，无法区分循环队列是满还是空。区分循环队列是空还是满的方法有三：

- 设置一个空位
- 设置一个标志：队列空：如果由于出列操作，改变了𝑓𝑟𝑜𝑛𝑡指针，使得𝑓𝑟𝑜𝑛𝑡 = 𝑟𝑒𝑎𝑟；队列满：如果由于入列操作，改变了𝑟𝑒𝑎𝑟指针，使得𝑓𝑟𝑜𝑛𝑡 = 𝑟𝑒𝑎𝑟
- 设置队列长度变量



#### 队列的链式存储

。。。

#### 队列的应用

##### 缓冲区

用于构建缓冲区，以处理不同设备之间的速度差异



## 串

串是有限长度的字符序列。

串中任意多个连续的字符组成的子序列称为该串的**子串**。 包含该子串的串称为子串的**主串**。

子串在主串中的位置指的是该子串的第一个字符在主串中 的位置。

串的操作经常以子串为单位进行，这是与线性表的区别。



串类型的最小操作子集：

- 串赋值 StrAssign
- 串复制 StrCopy （strcpy）
- 串比较 StrCompare （strcmp）
- 求串长 StrLength （strlen）
- 串联接 StrCat （strcat）
- 求子串 SubString



串的存储方式与一般线性表的存储方式类似：

- 顺序存储：
  - 定长顺序存储
  - 变长顺序存储
- 链式存储



### 串的模式匹配

已知目标串T和模式串P，模 式匹配就是要在目标串T中 找到一个与模式串P相等的 子串（子串定位）。

串匹配算法的应用：

- 文本编辑
- 程序调试
- 搜索引擎
- 病毒防范
- 生命科学



### 串的匹配算法

#### 蛮力法

**穷举匹配**：T的每个位置都作为可能的起始位置，与模式串 P逐次进行比较把目标串，如果相等，则匹配成功，过程终 止；如果不成功，就一直比较下去，知道遍历目标串的所 有位置，匹配失败，过程终止。

假设目标串𝑇的长度为𝑛，模式串𝑃的长度为𝑚，蛮力法最坏 情况下的时间复杂度为𝑂(𝑛 × 𝑚)



#### KMP算法

Knüth-Morris-Pratt算法

重点是模式串$P$的预处理。

**Next函数十分精妙**

KMP算法的时间复杂度为$O(m+n)$

在最坏情况下，KMP算法的时间效率都要远好于蛮力算法。

- Next函数的建立方法与KMP算法一致。
- KMP算法利用了子串的信息以提高速度。



#### Horspool算法

- Horspool算法是Boyer-Moore算法的简化版本。
- Boyer-Moore 查找算法在最坏情况下的时间复杂度也是 𝑂(𝑛)。

最坏情况下的时间复杂度为𝑂(𝑛𝑚 + 𝑠)，𝑠为字符表规模



战术上的勤奋和战略上的懒惰



## 树与二叉树

### 树

有且仅有一个根结点，只有直接后继，没有前驱

根的子树

**除根结点外，其余结点都有唯一的路径连接到根结点**



树中不存在封闭的回路

- 结点：树的基本单位
- 结点的度：节点的子树个数
- 分支结点：度不为零
- 叶子结点：度为零
- 树的度：树中结点的度的最大值
- 如果树的度为k，则称这棵树为k叉树



基本术语：

- 孩子结点
- 双亲结点或父结点
- 兄弟结点
- 堂兄弟
- 祖先
- 子孙



结点的层次

树的深度

树中的结点数目等于所有结点的度数和加1



k叉树的层次从1开始，度为k的树中第i层上至多$k^{i-1}$个结点

深度为$h$的$k$叉树至多有$\frac{k^h-1}{k-1}$个结点

具有$n$个结点的$k$叉树最小深度为$[\log_k(n\times(k-1)+1)]$



### 二叉树

左子树，左孩子

右子树，右孩子



二叉树的子树有左右之分，不能互换



若二叉树有$n_0$个叶子结点，$n_2$个2度结点，则$n_0=n_2+1$



**完全二叉树**：高度为h，除了第h层外，其他各层都达到最大结点个数，第h层从右向左**连续**缺失若干个结点。完全二叉树中编号0到𝑛 − 1的𝑛个结点和满二叉树中编号为 0至𝑛 − 1的𝑛个结点一一对应



满二叉树是完全二叉树的特例

𝑛个结点的二叉树中，完全二叉树具有最小的深度



**可以通过完全二叉树的编号确定很多信息**



#### 遍历

- 前序遍历：V-L-R
- 中序遍历：L-V-R
- 后序遍历：L-R-V



- 层序遍历



应用：

- 运算表达式的树表示：中序遍历可以得到中缀表达式，后序表达式可以得到后缀表达式



可以利用堆栈结构实现遍历。

可以利用队列结构实现层序遍历。



已知二叉树的某一前序序列，并不能确定这棵二叉树

同时给定前序序列和中序序列可唯一地确定一棵二叉树



### 二叉搜索树

二叉搜索树是一种动态查找结构，效率可达$O(\log_2n)$

虽然二叉搜索树是非线性结构，但却隐含了一个线性有 序序列。

中序遍历可以得到一个有序序列



平衡二叉树：任意结点的两子树的高度差都小于1

二叉搜索树查找算法的时间复杂度与树的形态有关，查找 次数不超过其深度



### 二叉树的应用：霍夫曼编码

- 结点到结点的分支称为路径
- 路径上的分支数称为路径长度
- 结点的路径长度定义为从根节点到该节点的路径上分支的数目
- 树的路径长度是从树根到所有叶子结点的路径长度之和
- 对分支加权的路径长度称为带权路径长度
- 树的带权路径长度为树中所有叶子结点的带权路径长度之和



霍夫曼树：在所有路径长度相同的二 叉树中，𝑊𝑃𝐿最小的树称 为最优二叉树，或霍夫曼 树（Huffman Tree）在霍夫 曼树中，权值大的结点离 根最近

**霍夫曼树的构造方法**

霍夫曼算法中的树中只有度为0和度为2的结点





**前缀编码：编码后任一字符的编码都不是其它字符编码的前缀**

变（变化）长前缀编码实例：摩尔斯电码



- 霍夫曼编码是完全依据字符出现概率来构造平均码长最短的 编码方案，有时也称为最佳编码，一般就叫作霍夫曼编码
- 霍夫曼编码满足前缀编码的性质，因此可以即时解码
- 霍夫曼编码是一种可以严格证明的最优编码



**霍夫曼编码举例**



霍夫曼编码的不足：

- 没有错误保护功能
- 编码之前需要精准统计文本文字的字符出现的概率
- 在霍夫曼编码过程中需要用到排序的操作





### 优先级队列与堆

优先级队列 ：队列中每个元素都增加一个代表其优先级的 权值，根据权值访问优先级最高的元素



#### 堆

堆是一种满足特定性质的完全二叉树

- 最大堆：任一结点的值都小于其父结点的值
- 最小堆：任一结点的值都大于其父结点的值



自顶向下堆化

自底向上堆化



自顶向下构造堆和自底向上构造堆



**堆才是实现优先级队列的主要数据结构之一**



## 图

每个元素可以有多个前驱和多个后继



**图论是数据结构和算法中最重要的框架**



在图中并不存在特殊的根结点，每个结点都可能存在多个 相邻的结点

- V的元素称为顶点
- 关系被称为边或弧
- 邻接顶点
- 权：图的边具有与之相关的数（带权图也被称为网络）
- 简单图
- 有向图，无向图
- 有向完全图，无向完全图
- 稀疏图，稠密图
- 子图



任意一个图一定有偶数个奇点

极大连通子图：图𝐺中任何不属于这个子图的顶点与子图中的任何一个 顶点都是不连通的

无向图的极大连通子图称为连通分量



**有向图**中，每个元素都存在路径，那么称该子图为强连通图

有向图的极大强连通子图称为有向图的强连通分量



Euler路径是遍历图中每条边且只访问一次的路径

终点回到起点的Euler路径是Euler回路















































































